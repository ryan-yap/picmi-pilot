{
  "name": "geo-proximity",
  "version": "2.1.0",
  "author": {
    "name": "Arjun Mehta",
    "email": "arjunmeht@gmail.com",
    "url": "http://www.arjunmehta.net/"
  },
  "description": "Super fast proximity searches of geo coordinates.",
  "keywords": [
    "geohash",
    "proximity",
    "nearby",
    "redis",
    "geolocation",
    "geoproximity",
    "radius"
  ],
  "repository": {
    "url": "https://github.com/arjunmehta/node-geo-proximity"
  },
  "dependencies": {
    "ngeohash": "~0.6.0"
  },
  "devDependencies": {
    "nodeunit": "~0.9.0",
    "redis": "~0.10.0"
  },
  "scripts": {
    "test": "nodeunit test/test.js"
  },
  "main": "./main",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/arjunmehta/node-geo-proximity/issues"
  },
  "homepage": "https://github.com/arjunmehta/node-geo-proximity",
  "readme": "geo-proximity\n=====================\n\n[![Build Status](https://travis-ci.org/arjunmehta/node-geo-proximity.svg?branch=master)](https://travis-ci.org/arjunmehta/node-geo-proximity)\n\n**Note:** *The API for v2.x.x has been completely rewritten!*<br/>\n**Note:** *This module requires a [Redis](http://redis.io) server to be accessible to your Node environment.*\n\n![geo-proximity title image](https://raw.githubusercontent.com/arjunmehta/node-geo-proximity/image/image/splash.png)\n\nThis Node module provides everything you need to get proximity information for geo locations. More specifically:\n\n- **Fast querying of nearby locations to a point within a set. Fast like redis is fast.**\n- **Basic management (addition, querying and removal) of sets of named geo locations.**\n- **A simple, easy to use, scalable interface.**\n- **Built-in query caching for improved performance of repeated queries.**\n\nIt should be noted that the method used here is not the most precise, but the query is very fast, and should be appropriate for most consumer applications looking for this basic function. [Read more about how this module works](http://gis.stackexchange.com/questions/18330/would-it-be-possible-to-use-geohash-for-proximity-searches/92331#92331).\n\n## Installation\n\n```bash\nnpm install geo-proximity\n```\n\n## Basic Usage\nUsage of this module should be extremely simple. Just make sure that your redis server is accessible to your Node environment. Because this module uses redis as a store, almost all methods have integrated error handling for queries.\n\n### Include and Initialize\n\nInclude and initialize this module with a node-redis client instance.\n\n```javascript\nvar redis = require('redis'),\n    client = redis.createClient()\n\nvar proximity = require('geo-proximity').initialize(client)\n```\n\n### Add Locations\n\nAdd locations individually:\n\n```javascript\nproximity.addLocation(43.6667, -79.4167, 'Toronto', function(err, reply){\n  if(err) console.error(err)\n  else console.log('added location:', reply)\n})\n```\n\nIf you have a large set you'd like to add in bulk, there's a much quicker way:\n\n```javascript\nvar locations = [[43.6667, -79.4167,  'Toronto'],\n                 [39.9523, -75.1638,  'Philadelphia'],\n                 [37.4688, -122.1411, 'Palo Alto'],\n                 [37.7691, -122.4449, 'San Francisco'],\n                 [47.5500, -52.6667,  'St. John\\'s'],\n                 [40.7143, -74.0060,  'New York'],\n                 [49.6500, -54.7500,  'Twillingate'],\n                 [45.4167, -75.7000,  'Ottawa'],\n                 [51.0833, -114.0833, 'Calgary'],\n                 [18.9750, 72.8258,   'Mumbai']]\n\nproximity.addLocations(locations, function(err, reply){\n  if(err) console.error(err)\n  else console.log('added locations:', reply)\n})\n```\n\n\n### Recall the Coordinates of a Location\n\n```javascript\nproximity.location('Toronto', function(err, location){\n  if(err) console.error(err)\n  else console.log(location.name + \"'s location is:\", location.latitude, location.longitude)\n})\n```\n\nOr for multiple locations:\n\n```javascript\nproximity.locations(['Toronto', 'Philadelphia', 'Palo Alto', 'San Francisco', 'Ottawa'], function(err, locations){\n  if(err) console.error(err)\n  else {\n    for(var i = 0; i < locations.length; i++)\n      console.log(locations[i].name + \"'s location is:\", locations[i].latitude, locations[i].longitude)\n  }\n})\n```\n\n### Search for Nearby Locations\n\nNow you can look for locations that exist within a certain range of any particular coordinate in the system.\n\n```javascript\n// look for all points within 5000m of Toronto.\nproximity.nearby(43.646838, -79.403723, 5000, function(err, locations){\n  if(err) console.error(err)\n  else console.log('nearby locations:', locations)\n})\n```\n\n### Remove Locations\nOf course you may need to remove some points from your set as users/temporary events/whatever no longer are part of the set.\n\n```javascript\nproximity.removeLocation('New York', function(err, reply){\n  if(err) console.error(err)\n  else console.log('removed location:', reply)\n})\n\n// OR Quicker for Bulk Removals\nproximity.removeLocations(['New York', 'St. John\\'s', 'San Francisco'], function(err, reply){\n  if(err) console.error(err)\n  else console.log('removed locations', reply)\n})\n```\n\n\n## Advanced Usage\n\n### Initializing with Options\n\nYou can initialize `geo-proximity` with a specific redis client instance, but you can also specify a ZSET name to use when storing/querying locations instead of the default `geo:locations`. You may also enable an experimental caching feature that should help with performance, but will use additional memory.\n\n```javascript\nvar redis = require('redis'),\n    client = redis.createClient()\n\nvar proximity = require('geo-proximity').initialize(client, {\n  zset: 'mySpecialLocationsSet',\n  cache: true\n})\n```\n\n### Multiple Sets\nIf you have different sets of coordinates, you can store and query them separately by creating adding a new set.\n\n#### Create Sets\n```javascript\nvar people = proximity.addSet('people')\nvar places = proximity.addSet('places')\n```\n\n#### Add Locations to Different Sets\n```javascript\nvar peopleLocations = [[43.6667,-79.4167,   'John'],\n                       [39.9523, -75.1638,  'Shankar'],\n                       [37.4688, -122.1411, 'Cynthia'],\n                       [37.7691, -122.4449, 'Chen']]\n\nvar placeLocations  = [[43.6667,-79.4167,   'Toronto'],\n                       [39.9523, -75.1638,  'Philadelphia'],\n                       [37.4688, -122.1411, 'Palo Alto'],\n                       [37.7691, -122.4449, 'San Francisco'],\n                       [47.5500, -52.6667,  'St. John\\'s']]\n\npeople.addLocations(peopleLocations, function(err, reply){\n  if(err) console.error(err)\n  else console.log('added people:', reply)\n})\n\nplaces.addLocations(placeLocations, function(err, reply){\n  if(err) console.error(err)\n  else console.log('added places:', reply)\n})\n```\n\n#### Look for Nearby Locations In Different Sets\n\n```javascript\n// will find all PEOPLE ~5000m from the passed in coordinate\npeople.nearby(43.646838, -79.403723, 5000, function(err, people){\n  if(err) console.error(err)\n  else console.log('people nearby:', people)\n})\n\n// will find all PLACES ~5000m from the passed in coordinate\nplaces.nearby(43.646838, -79.403723, 5000, function(err, places){\n  if(err) console.error(err)\n  else console.log('places nearby:', places)\n})\n```\n\n## Performant Querying\nIf you intend on performing the same query over and over again with the same initial coordinate and the same distance, you can cache the **geohash ranges** that are used to search for nearby locations. Use the **proximity.getQueryCache** and **proximity.nearbyWithQueryCache** methods together in order to do this.\n\nThe geohash ranges are what the **proximity.nearby** method ultimately searches within to find nearby points. So keeping these stored in a variable some place and passing them into a more basic search function will save some cycles (at least 5ms on a basic machine). This will save you quite a bit of processing time if you expect to refresh your searches often, and especially if you expect to have empty results often. Your processor is probably best used for other things.\n\n```javascript\nvar cachedQuery = proximity.getQueryCache(37.4688, -122.1411, 5000)\n\nproximity.nearbyWithQueryCache(cachedQuery, function(err, replies){\n  console.log('results to the query:', replies)\n})\n```\n\n\n## API\n\n### proximity.initialize(redisClient, options)\nInitialize the module with a redis client.\n\n#### Options\n- `zset` **String**: Default `geo:locations`. Set this option to specify a zset name to use to store location values.\n- `cache` **Boolean**: Default `false`. The module can cache queries to increase the speed of future queries that are similar. However, this can end up taking a bit of memory, and might not be necessary if you don't need to repeat queries.\n\n```javascript\nvar proximity = require('geo-proximity').initialize(client, {\n  zset: 'locations',\n  cache: false\n})\n```\n\n### proximity.addSet(setName)\nThis method will return a subset that can be queried and hold a unique set of locations from the main set. It will store these new locations in a new redis zset with a unique name related to the parent set (eg. `geo:locations:people`).\n\n### proximity.addLocation(lat, lon, locationName, callBack)\nAdd a new coordinate to your set.\n\n### proximity.addLocations(locationArray, callBack)\nAdds an array of new coordinates to your set. The `coordinateArray` must be in the form `[[lat, lon, name],[lat, lon, name],...,[lat, lon, name]]`. Use this method for bulk additions, as it is much faster than individual adds.\n\n### proximity.location(locationName, callBack)\nRetrieve the latitude and longitude of a specific named location. Returns an object with `name`, `latitude` and `longitude` properties.\n\n### proximity.locations(locationNameArray, callBack)\nRetrieve the latitude and longitude of a list of specific named locations. Returns an array of objects with `name`, `latitude` and `longitude` properties.\n\n### proximity.addLocations(coordinateArray, callBack)\nAdds an array of new coordinates to your set. The `coordinateArray` must be in the form `[[lat, lon, name],[lat, lon, name],...,[lat, lon, name]]`. Use this method for bulk additions, as it is much faster than individual adds.\n\n### proximity.removeLocation(coordinateName, callBack)\nRemove the specified coordinate by name.\n\n### proximity.removeLocations(coordinateNameArray, callBack)\nRemove a set of coordinates by name. `coordinateNameArray` must be of the form `[nameA,nameB,nameC,...,nameN]`.\n\n### proximity.nearby(lat, lon, radius, {options}, callBack)\nUse this function for a basic search by proximity within the given latitude and longitude and radius (in meters). It is not ideal to use this method if you intend on making the same query multiple times. **If performance is important and you'll be making the same query over and over again, it is recommended you instead have a look at proximity.nearbyWithQueryCache and promixity.getQueryCache.** Otherwise this is an easy method to use.\n\n#### Options\n- `values` **Boolean**: Default `false`. Instead of returning a flat array of key names, it will instead return a full set of keynames with coordinates in the form of `[[name, lat, lon], [name, lat, lon]...]`.This will be a slower query compared to just returning the keynames because the coordinates need to be calculated from the stored geohashes.\n\n### proximity.getQueryCache(lat, lon, radius)\nGet the query ranges to use with **proximity.nearbyWithQueryCache**. This returns an array of geohash ranges to search your set for. `bitDepth` is optional and defaults to 52, set it if you have chosen to store your coordinates at a different bit depth. Store the return value of this function for making the same query often.\n\n### proximity.nearbyWithQueryCache(cache, {options}, callBack)\nPass in query ranges returned by **proximity.getQueryRangesFromRadius** to find points that fall within your range value.\n\n#### Options\n- `values` **Boolean**: Default `false`. Instead of returning a flat array of key names, it will instead return a full set of keynames with coordinates in the form of `[[name, lat, lon], [name, lat, lon]...]`.This will be a slower query compared to just returning the keynames because the coordinates need to be calculated from the stored geohashes.\n\n\n## License\n\nThe MIT License (MIT)<br/>\nCopyright (c) 2015 Arjun Mehta\n",
  "readmeFilename": "README.md",
  "_id": "geo-proximity@2.1.0",
  "_from": "geo-proximity@"
}
